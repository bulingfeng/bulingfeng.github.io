---
title: "常见问题总结"
subtitle: "常见问题总结"
layout: post
author: "bulingfeng"
header-style: text
tags:
- java基础
---

## 关于ThreadLocal问题

ThreadLocal在使用结束的时候，要强制调用remove方法来进行把对应线程持有的ThreadLocalMap的引用给释放掉，否则会引起OOM。

1. tomcat为共享线程池，然后ThreadLocal没有主动调用remove方法导致内存泄露
2. 没有主动调用remove方法，由于tomcat是线程池复用，所以造成同一个线程中的用户信息不一致。比如一个线程的上下文信息，刚开始是A用户信息，结果一会变成了B用户的信息（线程池内线程复用造成的）

## JVM调优问题

有几种情况年轻代的对象会直接进入到老年代

1、survivor区域放不下了，这个时候会直接进入老年代。因为老年代有内存分担的指责。

2、当有大对象的时候，默认是1M，这个时候年轻代对象会直接进入到老年代。

3、年轻带回收的次数达到某个指标的时候，默认是15次则会进入到老年代。

### 案例

1、某个对象中的list对象竟然使用的static修饰，从而导致这个对象一直不能被回收,从而导致OOM。比如：

`public static List<String> list=new ArrayList();`

2、EXCEL导出的时候一次性的对象太多，从而造成频繁的Full GC，甚至发生OOM。

3、调用HTTP链接的时候，没有设置超时时间从而导致链接一直未关闭，从而导致链接一直未销毁从而造成对象一直在积累从而产生OOM

4、Survivor分配的内存太小，从而造成频繁的发生Full GC。案例如下：

```
https://blog.csdn.net/weixin_43519121/article/details/119835998
```

## MYSQL相关

1、有没有没有使用truncat命令，从而导致数据库的表的索引急剧增大，从而导致查询效率非常慢。
2、spring注解的使用没有理解到位从而造成事务的失效。
