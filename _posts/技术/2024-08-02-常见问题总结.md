---
title: "常见问题总结"
subtitle: "常见问题总结"
layout: post
author: "bulingfeng"
header-style: text
tags:
- java基础
---

## 关于ThreadLocal问题

ThreadLocal在使用结束的时候，要强制调用remove方法来进行把对应线程持有的ThreadLocalMap的引用给释放掉，否则会引起OOM。

1. tomcat为共享线程池，然后ThreadLocal没有主动调用remove方法导致内存泄露
2. 没有主动调用remove方法，由于tomcat是线程池复用，所以造成同一个线程中的用户信息不一致。比如一个线程的上下文信息，刚开始是A用户信息，结果一会变成了B用户的信息（线程池内线程复用造成的）

## JVM调优问题

有几种情况年轻代的对象会直接进入到老年代

1、survivor区域放不下了，这个时候会直接进入老年代。因为老年代有内存分担的指责。

2、当有大对象的时候，默认是1M，这个时候年轻代对象会直接进入到老年代。

3、年轻带回收的次数达到某个指标的时候，默认是15次则会进入到老年代。

### 案例

1、某个对象中的list对象竟然使用的static修饰，从而导致这个对象一直不能被回收,从而导致OOM。比如：

`public static List<String> list=new ArrayList();`

2、EXCEL导出的时候一次性的对象太多，从而造成频繁的Full GC，甚至发生OOM。

3、调用HTTP链接的时候，没有设置超时时间从而导致链接一直未关闭，从而导致链接一直未销毁从而造成对象一直在积累从而产生OOM

4、Survivor分配的内存太小，从而造成频繁的发生Full GC。案例如下：

```
https://blog.csdn.net/weixin_43519121/article/details/119835998
```

## MYSQL相关

1、有没有没有使用truncat命令，从而导致数据库的表的索引急剧增大，从而导致查询效率非常慢。其实delete语句并没有把数据给删除掉，只是给数据设置了一个标签来证明删除过。
2、spring注解的使用没有理解到位从而造成事务的失效。

3、错误的使用spring的事务注解导致业务异常。比如在递归方法上使用事务注解。
4、订单号取消唯一索引，改成普通索引提高访问的效率；由于分发订单号的系统能够保证唯一性，所以所以可以改用普通索引。而且这个订单号不能使用uuid来做，因为利用不到各种优势。


## 精准学
1. spring的三级缓存各种存的是什么？如何解决循环依赖的
2. mysql的mvcc
3. redis常见的5种数据结构，并且内部是如何实现的
4. 门面模式和装饰器模式等区别
4. 3G JVM 4G docker分配的内存 64G的机器 OOM 分析原因

## 国创能投
1. nginx是如何平滑启动的
2. mysql是如何保证数据不丢失的
3. redis链接数飙升，但是请求的qps又不是很多